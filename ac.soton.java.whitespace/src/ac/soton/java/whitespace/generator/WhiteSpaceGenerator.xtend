/*
 * generated by Xtext 2.15.0
 */
package ac.soton.java.whitespace.generator

import ac.soton.java.whitespace.WhiteSpacePrettyPrinter
import ac.soton.java.whitespace.whiteSpace.Addition
import ac.soton.java.whitespace.whiteSpace.CallSubroutine
import ac.soton.java.whitespace.whiteSpace.Copy
import ac.soton.java.whitespace.whiteSpace.Discard
import ac.soton.java.whitespace.whiteSpace.Division
import ac.soton.java.whitespace.whiteSpace.Duplicate
import ac.soton.java.whitespace.whiteSpace.EndProgram
import ac.soton.java.whitespace.whiteSpace.EndSubroutine
import ac.soton.java.whitespace.whiteSpace.MarkLocation
import ac.soton.java.whitespace.whiteSpace.Modulo
import ac.soton.java.whitespace.whiteSpace.Multiplication
import ac.soton.java.whitespace.whiteSpace.NegativeJump
import ac.soton.java.whitespace.whiteSpace.OutputCharacter
import ac.soton.java.whitespace.whiteSpace.OutputNumber
import ac.soton.java.whitespace.whiteSpace.Push
import ac.soton.java.whitespace.whiteSpace.ReadCharacter
import ac.soton.java.whitespace.whiteSpace.ReadNumber
import ac.soton.java.whitespace.whiteSpace.Retrieve
import ac.soton.java.whitespace.whiteSpace.Slide
import ac.soton.java.whitespace.whiteSpace.Statement
import ac.soton.java.whitespace.whiteSpace.Store
import ac.soton.java.whitespace.whiteSpace.Subtraction
import ac.soton.java.whitespace.whiteSpace.Swap
import ac.soton.java.whitespace.whiteSpace.UnconditionalJump
import ac.soton.java.whitespace.whiteSpace.WSProgram
import ac.soton.java.whitespace.whiteSpace.ZeroJump
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.Stack
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhiteSpaceGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val program = resource.contents.get(0)
		if (program instanceof WSProgram) {
			val wsFilename = resource.URI.lastSegment
			val stkFilename = wsFilename.replaceAll('.ws', '.stk')
			// Pretty Print the WSProgram
			fsa.generateFile(
				stkFilename,
				(new WhiteSpacePrettyPrinter()).prettyPrint(program)
			)
			
			// Create the program array list of statements
			val programHeap = new ArrayList<Statement>();
			val contents = program.eContents
			contents.forEach [ statement |
				if (statement instanceof Statement) {
					programHeap.add(statement)
				}
			]

			// Mapping from label to array indices
			var labels = new HashMap<String, Integer>()
			for (var i = 0; i < programHeap.length; i++) {
				val statement = programHeap.get(i)
				if (statement instanceof MarkLocation) {
					val label = statement.label
					labels.put(label, i)
				}
			}
			
			val heap = new HashMap<Integer, Integer>(); // Heap for Integers
			val stack = new Stack<Integer>(); // Stack for Integer
			val callStack = new Stack<Integer>(); // Stack for subroutine calls 

			var pc = 0; // The program counter
			while (pc < programHeap.length) {
				pc = execute(pc, programHeap, labels, callStack, heap, stack)
			}
			val memFilename = wsFilename.replaceAll('.ws', '.mem')
			fsa.generateFile(
				memFilename,
				'Heap\n' + heap.toString() + '\n' +
				'Stack\n' + stack.toString()
			)
		}
	}

	def int execute(int pc, List<Statement> programHeap, Map<String, Integer> labels, Stack<Integer> callStack,
		Map<Integer, Integer> heap, Stack<Integer> stack) {
		val statement = programHeap.get(pc)

		// Stack manipulation, i.e., Push, Duplicate, Copy, Swap, Discard, and Slide
		if (statement instanceof Push) {
			var number = statement.number
			stack.push(number)
			return pc + 1
		}
		if (statement instanceof Duplicate) {
			val top = stack.peek
			stack.push(top)
			return pc + 1
		}
		if (statement instanceof Copy) {
			val number = statement.number
			val value = stack.get(number)
			stack.push(value)
			return pc + 1
		}
		if (statement instanceof Swap) {
			val top1 = stack.pop
			val top2 = stack.pop
			stack.push(top1)
			stack.push(top2)
			return pc + 1
		}
		if (statement instanceof Discard) {
			stack.pop
			return pc + 1
		}
		if (statement instanceof Slide) {
			val number = statement.number
			val top = stack.pop
			for (var i = 0; i < number; i++) {
				stack.pop
			}
			stack.push(top)
			return pc + 1
		}

		// Arithmetic, i.e., Addition, Subtraction, Multiplication, Division, and Modulo
		if (statement instanceof Addition) {
			val top1 = stack.pop
			val top2 = stack.pop
			stack.push(top2 + top1)
			return pc + 1
		}

		if (statement instanceof Subtraction) {
			val top1 = stack.pop
			val top2 = stack.pop
			stack.push(top2 - top1)
			return pc + 1
		}

		if (statement instanceof Multiplication) {
			val top1 = stack.pop
			val top2 = stack.pop
			stack.push(top2 * top1)
			return pc + 1
		}

		if (statement instanceof Division) {
			val top1 = stack.pop
			val top2 = stack.pop
			stack.push(top2 / top1)
			return pc + 1
		}

		if (statement instanceof Modulo) {
			val top1 = stack.pop
			val top2 = stack.pop
			stack.push(top2 % top1)
			return pc + 1
		}

		// Heap access, i.e., Store and Retrieve
		if (statement instanceof Store) {
			val value = stack.pop
			val loc = stack.pop
			heap.put(loc, value)
			return pc + 1
		}

		if (statement instanceof Retrieve) {
			val loc = stack.pop
			val value = heap.get(loc)
			stack.push(value)
			return pc + 1
		}

		// FLow control, i.e., Mark Location, Call Subroutine, Unconditional Jump,
		// Zero Jump, Negative Jump, End Subroutine, End Program
		if (statement instanceof MarkLocation) {
			// Just go to the next statement
			return pc + 1	
		}

		if (statement instanceof CallSubroutine) {
			// Push the next statement on the call stack
			callStack.push(pc + 1)
			
			// Use the labels map to find the index of the label
			val label = statement.label
			return labels.get(label)
		}
		if (statement instanceof UnconditionalJump) {
			val label = statement.label
			return labels.get(label)	
		}
		if (statement instanceof ZeroJump) {
			val value = stack.pop
			if (value == 0) { // If the value is 0, jump to the label
				val label = statement.label
				return labels.get(label)
			} else { // Otherwise, go to the next statement
				return pc + 1
			}
		}
		if (statement instanceof NegativeJump) {
			val value = stack.pop
			if (value < 0) { // If the value negative, jump to the label
				val label = statement.label
				return labels.get(label)
			} else { // Otherwise, go to the next statement
				return pc + 1
			}
		}
		if (statement instanceof EndSubroutine) {
			// Pop and return the top of the call stack and
			return callStack.pop
		}

		if (statement instanceof EndProgram) {
			return programHeap.length
		}
		
		// I/O, i.e., Output Character, Output Number, Input Character, Input Number
		if (statement instanceof OutputCharacter) {
			val character = stack.pop
			System.out.print(Character.toChars(character))
			return pc + 1
		}
		if (statement instanceof OutputNumber) {
			val number = stack.pop
			System.out.print(number)
			return pc + 1
		}
		if (statement instanceof ReadCharacter) {
			// Create a bufferedReader from System.in
    	    val buffer = new BufferedReader(new InputStreamReader(System.in))
        
        	// Read the line
        	val str = buffer.readLine()
        	
        	stack.push(Character.getNumericValue(str.charAt(0)))
			return pc + 1
		}
		if (statement instanceof ReadNumber) {
			// Create a bufferedReader from System.in
    	    val buffer = new BufferedReader(new InputStreamReader(System.in))
        
        	// Read the line
        	val str = buffer.readLine()
        
        	val number =  Integer.parseInt(str)
        	stack.push(number)
			return pc + 1
		}
		throw new UnsupportedOperationException("Unknown statement " + statement)
	}

}
