/*
 * generated by Xtext 2.27.0
 */
package ac.soton.java.whitespace.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class WhiteSpaceGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class WSProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.WSProgram");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//WSProgram:
		//    statements +=Statement+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//statements +=Statement+
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStackManipulationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArithmeticParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHeapAccessParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFlowControlParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIOParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Statement:
		//    StackManipulation |
		//    Arithmetic |
		//    HeapAccess |
		//    FlowControl |
		//    IO
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//StackManipulation |
		//Arithmetic |
		//HeapAccess |
		//FlowControl |
		//IO
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//StackManipulation
		public RuleCall getStackManipulationParserRuleCall_0() { return cStackManipulationParserRuleCall_0; }
		
		//Arithmetic
		public RuleCall getArithmeticParserRuleCall_1() { return cArithmeticParserRuleCall_1; }
		
		//HeapAccess
		public RuleCall getHeapAccessParserRuleCall_2() { return cHeapAccessParserRuleCall_2; }
		
		//FlowControl
		public RuleCall getFlowControlParserRuleCall_3() { return cFlowControlParserRuleCall_3; }
		
		//IO
		public RuleCall getIOParserRuleCall_4() { return cIOParserRuleCall_4; }
	}
	public class StackManipulationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.StackManipulation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cPushParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cDuplicateParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cCopyParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cSwapParserRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final RuleCall cDiscardParserRuleCall_1_4 = (RuleCall)cAlternatives_1.eContents().get(4);
		private final RuleCall cSlideParserRuleCall_1_5 = (RuleCall)cAlternatives_1.eContents().get(5);
		
		///*
		// * Stack manipulation (IMP = [SPACE])
		// */
		//StackManipulation:
		//    SPACE // The Instruction Modification Parameter (IMP) for Stack manipulation
		//    (Push | Duplicate | Copy | Swap | Discard | Slide)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//SPACE // The Instruction Modification Parameter (IMP) for Stack manipulation
		//(Push | Duplicate | Copy | Swap | Discard | Slide)
		public Group getGroup() { return cGroup; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_0() { return cSPACETerminalRuleCall_0; }
		
		//// The Instruction Modification Parameter (IMP) for Stack manipulation
		//   (Push | Duplicate | Copy | Swap | Discard | Slide)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//Push
		public RuleCall getPushParserRuleCall_1_0() { return cPushParserRuleCall_1_0; }
		
		//Duplicate
		public RuleCall getDuplicateParserRuleCall_1_1() { return cDuplicateParserRuleCall_1_1; }
		
		//Copy
		public RuleCall getCopyParserRuleCall_1_2() { return cCopyParserRuleCall_1_2; }
		
		//Swap
		public RuleCall getSwapParserRuleCall_1_3() { return cSwapParserRuleCall_1_3; }
		
		//Discard
		public RuleCall getDiscardParserRuleCall_1_4() { return cDiscardParserRuleCall_1_4; }
		
		//Slide
		public RuleCall getSlideParserRuleCall_1_5() { return cSlideParserRuleCall_1_5; }
	}
	public class PushElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Push");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPushAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cNumberAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNumberNumberParserRuleCall_2_0 = (RuleCall)cNumberAssignment_2.eContents().get(0);
		
		//Push:
		//    {Push}
		//    SPACE number=Number
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Push}
		//SPACE number=Number
		public Group getGroup() { return cGroup; }
		
		//{Push}
		public Action getPushAction_0() { return cPushAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//number=Number
		public Assignment getNumberAssignment_2() { return cNumberAssignment_2; }
		
		//Number
		public RuleCall getNumberNumberParserRuleCall_2_0() { return cNumberNumberParserRuleCall_2_0; }
	}
	public class DuplicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Duplicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDuplicateAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Duplicate:
		//    {Duplicate}
		//    LF SPACE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Duplicate}
		//LF SPACE
		public Group getGroup() { return cGroup; }
		
		//{Duplicate}
		public Action getDuplicateAction_0() { return cDuplicateAction_0; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
	}
	public class CopyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Copy");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCopyAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberNumberParserRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		
		//Copy:
		//    {Copy}
		//    TAB SPACE number=Number
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Copy}
		//TAB SPACE number=Number
		public Group getGroup() { return cGroup; }
		
		//{Copy}
		public Action getCopyAction_0() { return cCopyAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
		
		//number=Number
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//Number
		public RuleCall getNumberNumberParserRuleCall_3_0() { return cNumberNumberParserRuleCall_3_0; }
	}
	public class SwapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Swap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSwapAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Swap:
		//    {Swap}
		//    LF TAB
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Swap}
		//LF TAB
		public Group getGroup() { return cGroup; }
		
		//{Swap}
		public Action getSwapAction_0() { return cSwapAction_0; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
	}
	public class DiscardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Discard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDiscardAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Discard:
		//    {Discard}
		//    LF LF
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Discard}
		//LF LF
		public Group getGroup() { return cGroup; }
		
		//{Discard}
		public Action getDiscardAction_0() { return cDiscardAction_0; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_2() { return cLFTerminalRuleCall_2; }
	}
	public class SlideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Slide");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSlideAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberNumberParserRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		
		//Slide:
		//    {Slide}
		//    TAB LF number=Number
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Slide}
		//TAB LF number=Number
		public Group getGroup() { return cGroup; }
		
		//{Slide}
		public Action getSlideAction_0() { return cSlideAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_2() { return cLFTerminalRuleCall_2; }
		
		//number=Number
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//Number
		public RuleCall getNumberNumberParserRuleCall_3_0() { return cNumberNumberParserRuleCall_3_0; }
	}
	public class ArithmeticElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Arithmetic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cAdditionParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cSubtractionParserRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_2_2 = (RuleCall)cAlternatives_2.eContents().get(2);
		private final RuleCall cDivisionParserRuleCall_2_3 = (RuleCall)cAlternatives_2.eContents().get(3);
		private final RuleCall cModuloParserRuleCall_2_4 = (RuleCall)cAlternatives_2.eContents().get(4);
		
		///*
		// * Arithmetic (IMP = [TAB][SPACE])
		// */
		//Arithmetic:
		//    TAB SPACE // The Instruction Modification Parameter (IMP) for Arithmetic
		//    (Addition | Subtraction | Multiplication | Division | Modulo)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//TAB SPACE // The Instruction Modification Parameter (IMP) for Arithmetic
		//(Addition | Subtraction | Multiplication | Division | Modulo)
		public Group getGroup() { return cGroup; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_0() { return cTABTerminalRuleCall_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//// The Instruction Modification Parameter (IMP) for Arithmetic
		//   (Addition | Subtraction | Multiplication | Division | Modulo)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//Addition
		public RuleCall getAdditionParserRuleCall_2_0() { return cAdditionParserRuleCall_2_0; }
		
		//Subtraction
		public RuleCall getSubtractionParserRuleCall_2_1() { return cSubtractionParserRuleCall_2_1; }
		
		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_2_2() { return cMultiplicationParserRuleCall_2_2; }
		
		//Division
		public RuleCall getDivisionParserRuleCall_2_3() { return cDivisionParserRuleCall_2_3; }
		
		//Modulo
		public RuleCall getModuloParserRuleCall_2_4() { return cModuloParserRuleCall_2_4; }
	}
	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAdditionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Addition:
		//    {Addition}
		//    SPACE SPACE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Addition}
		//SPACE SPACE
		public Group getGroup() { return cGroup; }
		
		//{Addition}
		public Action getAdditionAction_0() { return cAdditionAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
	}
	public class SubtractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Subtraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSubtractionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Subtraction:
		//    {Subtraction}
		//    SPACE TAB
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Subtraction}
		//SPACE TAB
		public Group getGroup() { return cGroup; }
		
		//{Subtraction}
		public Action getSubtractionAction_0() { return cSubtractionAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
	}
	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMultiplicationAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Multiplication:
		//    {Multiplication}
		//    SPACE LF
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Multiplication}
		//SPACE LF
		public Group getGroup() { return cGroup; }
		
		//{Multiplication}
		public Action getMultiplicationAction_0() { return cMultiplicationAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_2() { return cLFTerminalRuleCall_2; }
	}
	public class DivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Division");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDivisionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Division:
		//    {Division}
		//    TAB SPACE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Division}
		//TAB SPACE
		public Group getGroup() { return cGroup; }
		
		//{Division}
		public Action getDivisionAction_0() { return cDivisionAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
	}
	public class ModuloElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Modulo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModuloAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Modulo:
		//    {Modulo}
		//    TAB TAB
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Modulo}
		//TAB TAB
		public Group getGroup() { return cGroup; }
		
		//{Modulo}
		public Action getModuloAction_0() { return cModuloAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
	}
	public class HeapAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.HeapAccess");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cStoreParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cRetrieveParserRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		
		///*
		// * Heap Access(IMP = [TAB][TAB])
		// */
		//HeapAccess:
		//    TAB TAB // The Instruction Modification Parameter (IMP) for Heap Access
		//    (Store | Retrieve)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//TAB TAB // The Instruction Modification Parameter (IMP) for Heap Access
		//(Store | Retrieve)
		public Group getGroup() { return cGroup; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_0() { return cTABTerminalRuleCall_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//// The Instruction Modification Parameter (IMP) for Heap Access
		//   (Store | Retrieve)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//Store
		public RuleCall getStoreParserRuleCall_2_0() { return cStoreParserRuleCall_2_0; }
		
		//Retrieve
		public RuleCall getRetrieveParserRuleCall_2_1() { return cRetrieveParserRuleCall_2_1; }
	}
	public class StoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Store");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStoreAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Store:
		//    {Store}
		//    SPACE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Store}
		//SPACE
		public Group getGroup() { return cGroup; }
		
		//{Store}
		public Action getStoreAction_0() { return cStoreAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
	}
	public class RetrieveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Retrieve");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRetrieveAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Retrieve:
		//    {Retrieve}
		//    TAB
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Retrieve}
		//TAB
		public Group getGroup() { return cGroup; }
		
		//{Retrieve}
		public Action getRetrieveAction_0() { return cRetrieveAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
	}
	public class FlowControlElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.FlowControl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cMarkLocationParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cCallSubroutineParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cUnconditionalJumpParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cZeroJumpParserRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final RuleCall cNegativeJumpParserRuleCall_1_4 = (RuleCall)cAlternatives_1.eContents().get(4);
		private final RuleCall cEndSubroutineParserRuleCall_1_5 = (RuleCall)cAlternatives_1.eContents().get(5);
		private final RuleCall cEndProgramParserRuleCall_1_6 = (RuleCall)cAlternatives_1.eContents().get(6);
		
		///*
		// * Heap Access(IMP = [LF])
		// */
		//FlowControl:
		//    LF // The Instruction Modification Parameter (IMP) for Flow Control
		//    (
		//        MarkLocation |
		//        CallSubroutine |
		//        UnconditionalJump |
		//        ZeroJump |
		//        NegativeJump |
		//        EndSubroutine |
		//        EndProgram
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LF // The Instruction Modification Parameter (IMP) for Flow Control
		//(
		//    MarkLocation |
		//    CallSubroutine |
		//    UnconditionalJump |
		//    ZeroJump |
		//    NegativeJump |
		//    EndSubroutine |
		//    EndProgram
		//)
		public Group getGroup() { return cGroup; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_0() { return cLFTerminalRuleCall_0; }
		
		//// The Instruction Modification Parameter (IMP) for Flow Control
		//   (
		//       MarkLocation |
		//       CallSubroutine |
		//       UnconditionalJump |
		//       ZeroJump |
		//       NegativeJump |
		//       EndSubroutine |
		//       EndProgram
		//   )
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//MarkLocation
		public RuleCall getMarkLocationParserRuleCall_1_0() { return cMarkLocationParserRuleCall_1_0; }
		
		//CallSubroutine
		public RuleCall getCallSubroutineParserRuleCall_1_1() { return cCallSubroutineParserRuleCall_1_1; }
		
		//UnconditionalJump
		public RuleCall getUnconditionalJumpParserRuleCall_1_2() { return cUnconditionalJumpParserRuleCall_1_2; }
		
		//ZeroJump
		public RuleCall getZeroJumpParserRuleCall_1_3() { return cZeroJumpParserRuleCall_1_3; }
		
		//NegativeJump
		public RuleCall getNegativeJumpParserRuleCall_1_4() { return cNegativeJumpParserRuleCall_1_4; }
		
		//EndSubroutine
		public RuleCall getEndSubroutineParserRuleCall_1_5() { return cEndSubroutineParserRuleCall_1_5; }
		
		//EndProgram
		public RuleCall getEndProgramParserRuleCall_1_6() { return cEndProgramParserRuleCall_1_6; }
	}
	public class MarkLocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.MarkLocation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMarkLocationAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLabelAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLabelLabelParserRuleCall_3_0 = (RuleCall)cLabelAssignment_3.eContents().get(0);
		
		//MarkLocation:
		//    {MarkLocation}
		//    SPACE SPACE label=Label
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{MarkLocation}
		//SPACE SPACE label=Label
		public Group getGroup() { return cGroup; }
		
		//{MarkLocation}
		public Action getMarkLocationAction_0() { return cMarkLocationAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
		
		//label=Label
		public Assignment getLabelAssignment_3() { return cLabelAssignment_3; }
		
		//Label
		public RuleCall getLabelLabelParserRuleCall_3_0() { return cLabelLabelParserRuleCall_3_0; }
	}
	public class CallSubroutineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.CallSubroutine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCallSubroutineAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLabelAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLabelLabelParserRuleCall_3_0 = (RuleCall)cLabelAssignment_3.eContents().get(0);
		
		//CallSubroutine:
		//    {CallSubroutine}
		//    SPACE TAB label=Label
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{CallSubroutine}
		//SPACE TAB label=Label
		public Group getGroup() { return cGroup; }
		
		//{CallSubroutine}
		public Action getCallSubroutineAction_0() { return cCallSubroutineAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
		
		//label=Label
		public Assignment getLabelAssignment_3() { return cLabelAssignment_3; }
		
		//Label
		public RuleCall getLabelLabelParserRuleCall_3_0() { return cLabelLabelParserRuleCall_3_0; }
	}
	public class UnconditionalJumpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.UnconditionalJump");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnconditionalJumpAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLabelAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLabelLabelParserRuleCall_3_0 = (RuleCall)cLabelAssignment_3.eContents().get(0);
		
		//UnconditionalJump:
		//    {UnconditionalJump}
		//    SPACE LF label=Label
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{UnconditionalJump}
		//SPACE LF label=Label
		public Group getGroup() { return cGroup; }
		
		//{UnconditionalJump}
		public Action getUnconditionalJumpAction_0() { return cUnconditionalJumpAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_2() { return cLFTerminalRuleCall_2; }
		
		//label=Label
		public Assignment getLabelAssignment_3() { return cLabelAssignment_3; }
		
		//Label
		public RuleCall getLabelLabelParserRuleCall_3_0() { return cLabelLabelParserRuleCall_3_0; }
	}
	public class ZeroJumpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.ZeroJump");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cZeroJumpAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLabelAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLabelLabelParserRuleCall_3_0 = (RuleCall)cLabelAssignment_3.eContents().get(0);
		
		//ZeroJump:
		//    {ZeroJump}
		//    TAB SPACE label=Label
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{ZeroJump}
		//TAB SPACE label=Label
		public Group getGroup() { return cGroup; }
		
		//{ZeroJump}
		public Action getZeroJumpAction_0() { return cZeroJumpAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
		
		//label=Label
		public Assignment getLabelAssignment_3() { return cLabelAssignment_3; }
		
		//Label
		public RuleCall getLabelLabelParserRuleCall_3_0() { return cLabelLabelParserRuleCall_3_0; }
	}
	public class NegativeJumpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.NegativeJump");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNegativeJumpAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLabelAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLabelLabelParserRuleCall_3_0 = (RuleCall)cLabelAssignment_3.eContents().get(0);
		
		//NegativeJump:
		//    {NegativeJump}
		//    TAB TAB label=Label
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{NegativeJump}
		//TAB TAB label=Label
		public Group getGroup() { return cGroup; }
		
		//{NegativeJump}
		public Action getNegativeJumpAction_0() { return cNegativeJumpAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
		
		//label=Label
		public Assignment getLabelAssignment_3() { return cLabelAssignment_3; }
		
		//Label
		public RuleCall getLabelLabelParserRuleCall_3_0() { return cLabelLabelParserRuleCall_3_0; }
	}
	public class EndSubroutineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.EndSubroutine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEndSubroutineAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//EndSubroutine:
		//    {EndSubroutine}
		//    TAB LF
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{EndSubroutine}
		//TAB LF
		public Group getGroup() { return cGroup; }
		
		//{EndSubroutine}
		public Action getEndSubroutineAction_0() { return cEndSubroutineAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_2() { return cLFTerminalRuleCall_2; }
	}
	public class EndProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.EndProgram");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEndProgramAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//EndProgram:
		//    {EndProgram}
		//    LF LF
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{EndProgram}
		//LF LF
		public Group getGroup() { return cGroup; }
		
		//{EndProgram}
		public Action getEndProgramAction_0() { return cEndProgramAction_0; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_2() { return cLFTerminalRuleCall_2; }
	}
	public class IOElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.IO");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cOutputCharacterParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cOutputNumberParserRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		private final RuleCall cReadCharacterParserRuleCall_2_2 = (RuleCall)cAlternatives_2.eContents().get(2);
		private final RuleCall cReadNumberParserRuleCall_2_3 = (RuleCall)cAlternatives_2.eContents().get(3);
		
		///*
		// * I/O (IMP = [T][LF])
		// */
		//IO:
		//    TAB LF // The Instruction Modification Parameter (IMP) for I/O
		//    (
		//        OutputCharacter |
		//        OutputNumber |
		//        ReadCharacter |
		//        ReadNumber
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//TAB LF // The Instruction Modification Parameter (IMP) for I/O
		//(
		//    OutputCharacter |
		//    OutputNumber |
		//    ReadCharacter |
		//    ReadNumber
		//)
		public Group getGroup() { return cGroup; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_0() { return cTABTerminalRuleCall_0; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
		
		//// The Instruction Modification Parameter (IMP) for I/O
		//   (
		//       OutputCharacter |
		//       OutputNumber |
		//       ReadCharacter |
		//       ReadNumber
		//   )
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//OutputCharacter
		public RuleCall getOutputCharacterParserRuleCall_2_0() { return cOutputCharacterParserRuleCall_2_0; }
		
		//OutputNumber
		public RuleCall getOutputNumberParserRuleCall_2_1() { return cOutputNumberParserRuleCall_2_1; }
		
		//ReadCharacter
		public RuleCall getReadCharacterParserRuleCall_2_2() { return cReadCharacterParserRuleCall_2_2; }
		
		//ReadNumber
		public RuleCall getReadNumberParserRuleCall_2_3() { return cReadNumberParserRuleCall_2_3; }
	}
	public class OutputCharacterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.OutputCharacter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOutputCharacterAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//OutputCharacter:
		//    {OutputCharacter}
		//    SPACE SPACE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{OutputCharacter}
		//SPACE SPACE
		public Group getGroup() { return cGroup; }
		
		//{OutputCharacter}
		public Action getOutputCharacterAction_0() { return cOutputCharacterAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
	}
	public class OutputNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.OutputNumber");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOutputNumberAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//OutputNumber:
		//    {OutputNumber}
		//    SPACE TAB
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{OutputNumber}
		//SPACE TAB
		public Group getGroup() { return cGroup; }
		
		//{OutputNumber}
		public Action getOutputNumberAction_0() { return cOutputNumberAction_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_1() { return cSPACETerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
	}
	public class ReadCharacterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.ReadCharacter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReadCharacterAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSPACETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//ReadCharacter:
		//    {ReadCharacter}
		//    TAB SPACE
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{ReadCharacter}
		//TAB SPACE
		public Group getGroup() { return cGroup; }
		
		//{ReadCharacter}
		public Action getReadCharacterAction_0() { return cReadCharacterAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_2() { return cSPACETerminalRuleCall_2; }
	}
	public class ReadNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.ReadNumber");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReadNumberAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cTABTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//ReadNumber:
		//    {ReadNumber}
		//    TAB TAB
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{ReadNumber}
		//TAB TAB
		public Group getGroup() { return cGroup; }
		
		//{ReadNumber}
		public Action getReadNumberAction_0() { return cReadNumberAction_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_1() { return cTABTerminalRuleCall_1; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_2() { return cTABTerminalRuleCall_2; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		///*
		// * The data rules for numbers and labels (required value converter)
		// */
		//Number returns ecore::EInt:
		//    (SPACE|TAB)+ LF
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(SPACE|TAB)+ LF
		public Group getGroup() { return cGroup; }
		
		//(SPACE|TAB)+
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_0_0() { return cSPACETerminalRuleCall_0_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_0_1() { return cTABTerminalRuleCall_0_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
	}
	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.Label");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cSPACETerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cTABTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cLFTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Label returns ecore::EString:
		//    (SPACE|TAB)+ LF
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(SPACE|TAB)+ LF
		public Group getGroup() { return cGroup; }
		
		//(SPACE|TAB)+
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//SPACE
		public RuleCall getSPACETerminalRuleCall_0_0() { return cSPACETerminalRuleCall_0_0; }
		
		//TAB
		public RuleCall getTABTerminalRuleCall_0_1() { return cTABTerminalRuleCall_0_1; }
		
		//LF
		public RuleCall getLFTerminalRuleCall_1() { return cLFTerminalRuleCall_1; }
	}
	
	
	private final WSProgramElements pWSProgram;
	private final StatementElements pStatement;
	private final StackManipulationElements pStackManipulation;
	private final PushElements pPush;
	private final DuplicateElements pDuplicate;
	private final CopyElements pCopy;
	private final SwapElements pSwap;
	private final DiscardElements pDiscard;
	private final SlideElements pSlide;
	private final ArithmeticElements pArithmetic;
	private final AdditionElements pAddition;
	private final SubtractionElements pSubtraction;
	private final MultiplicationElements pMultiplication;
	private final DivisionElements pDivision;
	private final ModuloElements pModulo;
	private final HeapAccessElements pHeapAccess;
	private final StoreElements pStore;
	private final RetrieveElements pRetrieve;
	private final FlowControlElements pFlowControl;
	private final MarkLocationElements pMarkLocation;
	private final CallSubroutineElements pCallSubroutine;
	private final UnconditionalJumpElements pUnconditionalJump;
	private final ZeroJumpElements pZeroJump;
	private final NegativeJumpElements pNegativeJump;
	private final EndSubroutineElements pEndSubroutine;
	private final EndProgramElements pEndProgram;
	private final IOElements pIO;
	private final OutputCharacterElements pOutputCharacter;
	private final OutputNumberElements pOutputNumber;
	private final ReadCharacterElements pReadCharacter;
	private final ReadNumberElements pReadNumber;
	private final NumberElements pNumber;
	private final LabelElements pLabel;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSPACE;
	private final TerminalRule tTAB;
	private final TerminalRule tLF;
	private final TerminalRule tNOTWS;
	
	private final Grammar grammar;

	@Inject
	public WhiteSpaceGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pWSProgram = new WSProgramElements();
		this.pStatement = new StatementElements();
		this.pStackManipulation = new StackManipulationElements();
		this.pPush = new PushElements();
		this.pDuplicate = new DuplicateElements();
		this.pCopy = new CopyElements();
		this.pSwap = new SwapElements();
		this.pDiscard = new DiscardElements();
		this.pSlide = new SlideElements();
		this.pArithmetic = new ArithmeticElements();
		this.pAddition = new AdditionElements();
		this.pSubtraction = new SubtractionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pDivision = new DivisionElements();
		this.pModulo = new ModuloElements();
		this.pHeapAccess = new HeapAccessElements();
		this.pStore = new StoreElements();
		this.pRetrieve = new RetrieveElements();
		this.pFlowControl = new FlowControlElements();
		this.pMarkLocation = new MarkLocationElements();
		this.pCallSubroutine = new CallSubroutineElements();
		this.pUnconditionalJump = new UnconditionalJumpElements();
		this.pZeroJump = new ZeroJumpElements();
		this.pNegativeJump = new NegativeJumpElements();
		this.pEndSubroutine = new EndSubroutineElements();
		this.pEndProgram = new EndProgramElements();
		this.pIO = new IOElements();
		this.pOutputCharacter = new OutputCharacterElements();
		this.pOutputNumber = new OutputNumberElements();
		this.pReadCharacter = new ReadCharacterElements();
		this.pReadNumber = new ReadNumberElements();
		this.pNumber = new NumberElements();
		this.pLabel = new LabelElements();
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.ML_COMMENT");
		this.tSPACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.SPACE");
		this.tTAB = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.TAB");
		this.tLF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.LF");
		this.tNOTWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.java.whitespace.WhiteSpace.NOTWS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.java.whitespace.WhiteSpace".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//WSProgram:
	//    statements +=Statement+
	//;
	public WSProgramElements getWSProgramAccess() {
		return pWSProgram;
	}
	
	public ParserRule getWSProgramRule() {
		return getWSProgramAccess().getRule();
	}
	
	//Statement:
	//    StackManipulation |
	//    Arithmetic |
	//    HeapAccess |
	//    FlowControl |
	//    IO
	//;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	///*
	// * Stack manipulation (IMP = [SPACE])
	// */
	//StackManipulation:
	//    SPACE // The Instruction Modification Parameter (IMP) for Stack manipulation
	//    (Push | Duplicate | Copy | Swap | Discard | Slide)
	//;
	public StackManipulationElements getStackManipulationAccess() {
		return pStackManipulation;
	}
	
	public ParserRule getStackManipulationRule() {
		return getStackManipulationAccess().getRule();
	}
	
	//Push:
	//    {Push}
	//    SPACE number=Number
	//;
	public PushElements getPushAccess() {
		return pPush;
	}
	
	public ParserRule getPushRule() {
		return getPushAccess().getRule();
	}
	
	//Duplicate:
	//    {Duplicate}
	//    LF SPACE
	//;
	public DuplicateElements getDuplicateAccess() {
		return pDuplicate;
	}
	
	public ParserRule getDuplicateRule() {
		return getDuplicateAccess().getRule();
	}
	
	//Copy:
	//    {Copy}
	//    TAB SPACE number=Number
	//;
	public CopyElements getCopyAccess() {
		return pCopy;
	}
	
	public ParserRule getCopyRule() {
		return getCopyAccess().getRule();
	}
	
	//Swap:
	//    {Swap}
	//    LF TAB
	//;
	public SwapElements getSwapAccess() {
		return pSwap;
	}
	
	public ParserRule getSwapRule() {
		return getSwapAccess().getRule();
	}
	
	//Discard:
	//    {Discard}
	//    LF LF
	//;
	public DiscardElements getDiscardAccess() {
		return pDiscard;
	}
	
	public ParserRule getDiscardRule() {
		return getDiscardAccess().getRule();
	}
	
	//Slide:
	//    {Slide}
	//    TAB LF number=Number
	//;
	public SlideElements getSlideAccess() {
		return pSlide;
	}
	
	public ParserRule getSlideRule() {
		return getSlideAccess().getRule();
	}
	
	///*
	// * Arithmetic (IMP = [TAB][SPACE])
	// */
	//Arithmetic:
	//    TAB SPACE // The Instruction Modification Parameter (IMP) for Arithmetic
	//    (Addition | Subtraction | Multiplication | Division | Modulo)
	//;
	public ArithmeticElements getArithmeticAccess() {
		return pArithmetic;
	}
	
	public ParserRule getArithmeticRule() {
		return getArithmeticAccess().getRule();
	}
	
	//Addition:
	//    {Addition}
	//    SPACE SPACE
	//;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}
	
	//Subtraction:
	//    {Subtraction}
	//    SPACE TAB
	//;
	public SubtractionElements getSubtractionAccess() {
		return pSubtraction;
	}
	
	public ParserRule getSubtractionRule() {
		return getSubtractionAccess().getRule();
	}
	
	//Multiplication:
	//    {Multiplication}
	//    SPACE LF
	//;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}
	
	//Division:
	//    {Division}
	//    TAB SPACE
	//;
	public DivisionElements getDivisionAccess() {
		return pDivision;
	}
	
	public ParserRule getDivisionRule() {
		return getDivisionAccess().getRule();
	}
	
	//Modulo:
	//    {Modulo}
	//    TAB TAB
	//;
	public ModuloElements getModuloAccess() {
		return pModulo;
	}
	
	public ParserRule getModuloRule() {
		return getModuloAccess().getRule();
	}
	
	///*
	// * Heap Access(IMP = [TAB][TAB])
	// */
	//HeapAccess:
	//    TAB TAB // The Instruction Modification Parameter (IMP) for Heap Access
	//    (Store | Retrieve)
	//;
	public HeapAccessElements getHeapAccessAccess() {
		return pHeapAccess;
	}
	
	public ParserRule getHeapAccessRule() {
		return getHeapAccessAccess().getRule();
	}
	
	//Store:
	//    {Store}
	//    SPACE
	//;
	public StoreElements getStoreAccess() {
		return pStore;
	}
	
	public ParserRule getStoreRule() {
		return getStoreAccess().getRule();
	}
	
	//Retrieve:
	//    {Retrieve}
	//    TAB
	//;
	public RetrieveElements getRetrieveAccess() {
		return pRetrieve;
	}
	
	public ParserRule getRetrieveRule() {
		return getRetrieveAccess().getRule();
	}
	
	///*
	// * Heap Access(IMP = [LF])
	// */
	//FlowControl:
	//    LF // The Instruction Modification Parameter (IMP) for Flow Control
	//    (
	//        MarkLocation |
	//        CallSubroutine |
	//        UnconditionalJump |
	//        ZeroJump |
	//        NegativeJump |
	//        EndSubroutine |
	//        EndProgram
	//    )
	//;
	public FlowControlElements getFlowControlAccess() {
		return pFlowControl;
	}
	
	public ParserRule getFlowControlRule() {
		return getFlowControlAccess().getRule();
	}
	
	//MarkLocation:
	//    {MarkLocation}
	//    SPACE SPACE label=Label
	//;
	public MarkLocationElements getMarkLocationAccess() {
		return pMarkLocation;
	}
	
	public ParserRule getMarkLocationRule() {
		return getMarkLocationAccess().getRule();
	}
	
	//CallSubroutine:
	//    {CallSubroutine}
	//    SPACE TAB label=Label
	//;
	public CallSubroutineElements getCallSubroutineAccess() {
		return pCallSubroutine;
	}
	
	public ParserRule getCallSubroutineRule() {
		return getCallSubroutineAccess().getRule();
	}
	
	//UnconditionalJump:
	//    {UnconditionalJump}
	//    SPACE LF label=Label
	//;
	public UnconditionalJumpElements getUnconditionalJumpAccess() {
		return pUnconditionalJump;
	}
	
	public ParserRule getUnconditionalJumpRule() {
		return getUnconditionalJumpAccess().getRule();
	}
	
	//ZeroJump:
	//    {ZeroJump}
	//    TAB SPACE label=Label
	//;
	public ZeroJumpElements getZeroJumpAccess() {
		return pZeroJump;
	}
	
	public ParserRule getZeroJumpRule() {
		return getZeroJumpAccess().getRule();
	}
	
	//NegativeJump:
	//    {NegativeJump}
	//    TAB TAB label=Label
	//;
	public NegativeJumpElements getNegativeJumpAccess() {
		return pNegativeJump;
	}
	
	public ParserRule getNegativeJumpRule() {
		return getNegativeJumpAccess().getRule();
	}
	
	//EndSubroutine:
	//    {EndSubroutine}
	//    TAB LF
	//;
	public EndSubroutineElements getEndSubroutineAccess() {
		return pEndSubroutine;
	}
	
	public ParserRule getEndSubroutineRule() {
		return getEndSubroutineAccess().getRule();
	}
	
	//EndProgram:
	//    {EndProgram}
	//    LF LF
	//;
	public EndProgramElements getEndProgramAccess() {
		return pEndProgram;
	}
	
	public ParserRule getEndProgramRule() {
		return getEndProgramAccess().getRule();
	}
	
	///*
	// * I/O (IMP = [T][LF])
	// */
	//IO:
	//    TAB LF // The Instruction Modification Parameter (IMP) for I/O
	//    (
	//        OutputCharacter |
	//        OutputNumber |
	//        ReadCharacter |
	//        ReadNumber
	//    )
	//;
	public IOElements getIOAccess() {
		return pIO;
	}
	
	public ParserRule getIORule() {
		return getIOAccess().getRule();
	}
	
	//OutputCharacter:
	//    {OutputCharacter}
	//    SPACE SPACE
	//;
	public OutputCharacterElements getOutputCharacterAccess() {
		return pOutputCharacter;
	}
	
	public ParserRule getOutputCharacterRule() {
		return getOutputCharacterAccess().getRule();
	}
	
	//OutputNumber:
	//    {OutputNumber}
	//    SPACE TAB
	//;
	public OutputNumberElements getOutputNumberAccess() {
		return pOutputNumber;
	}
	
	public ParserRule getOutputNumberRule() {
		return getOutputNumberAccess().getRule();
	}
	
	//ReadCharacter:
	//    {ReadCharacter}
	//    TAB SPACE
	//;
	public ReadCharacterElements getReadCharacterAccess() {
		return pReadCharacter;
	}
	
	public ParserRule getReadCharacterRule() {
		return getReadCharacterAccess().getRule();
	}
	
	//ReadNumber:
	//    {ReadNumber}
	//    TAB TAB
	//;
	public ReadNumberElements getReadNumberAccess() {
		return pReadNumber;
	}
	
	public ParserRule getReadNumberRule() {
		return getReadNumberAccess().getRule();
	}
	
	///*
	// * The data rules for numbers and labels (required value converter)
	// */
	//Number returns ecore::EInt:
	//    (SPACE|TAB)+ LF
	//;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//Label returns ecore::EString:
	//    (SPACE|TAB)+ LF
	//;
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}
	
	///*
	// * The terminal rules for space, tab, line-feed and others (i.e., not white space)
	// */
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SPACE: ' ';
	public TerminalRule getSPACERule() {
		return tSPACE;
	}
	
	//terminal TAB: '\t';
	public TerminalRule getTABRule() {
		return tTAB;
	}
	
	//terminal LF: '\n';
	public TerminalRule getLFRule() {
		return tLF;
	}
	
	//terminal NOTWS:
	//    (!(' '|'\t'|'\n'))+
	//;
	public TerminalRule getNOTWSRule() {
		return tNOTWS;
	}
}
